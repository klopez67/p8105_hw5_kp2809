Homework 5: Iteration
================
Kimberly Lopez
2024-11-06

``` r
library(tidyverse)
```

    ## ── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──
    ## ✔ dplyr     1.1.4     ✔ readr     2.1.5
    ## ✔ forcats   1.0.0     ✔ stringr   1.5.1
    ## ✔ ggplot2   3.5.1     ✔ tibble    3.2.1
    ## ✔ lubridate 1.9.3     ✔ tidyr     1.3.1
    ## ✔ purrr     1.0.2     
    ## ── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──
    ## ✖ dplyr::filter() masks stats::filter()
    ## ✖ dplyr::lag()    masks stats::lag()
    ## ℹ Use the conflicted package (<http://conflicted.r-lib.org/>) to force all conflicts to become errors

``` r
library(rvest)
```

    ## 
    ## Attaching package: 'rvest'
    ## 
    ## The following object is masked from 'package:readr':
    ## 
    ##     guess_encoding

``` r
library(broom)
library(dplyr)
```

``` r
set.seed(5)
```

# Problem 1

# Problem 2

For one randomly generated sample of n=30, with mean = 0, and sd= 5, run
a t.test() and return the estimate & p-value:

``` r
sim_data = 
    tibble(
    x = rnorm (30, mean= 0, sd= 5))

t.test(sim_data)|>
  broom::tidy()|>
  select(estimate,p.value)
```

    ## # A tibble: 1 × 2
    ##   estimate p.value
    ##      <dbl>   <dbl>
    ## 1   0.0565   0.951

Function for performing a one-sample t-test and returning the estimate &
p-value

``` r
sim_t_test = function ( n , mu= 0, sigma =5) {
  
  sim_data = 
    tibble(
    x = rnorm (n, mean= mu, sd= sigma))
  
  sim_data|>
    t.test()|>
    broom::tidy()|>
    select(estimate, p.value)
  
}

sim_t_test(n=30)
```

    ## # A tibble: 1 × 2
    ##   estimate p.value
    ##      <dbl>   <dbl>
    ## 1    0.794   0.415

For 5000 datasets:

``` r
output = vector("list", 5000)

for (i in 1:5000) {
  output[[i]] = sim_t_test(n=30)
}

sim_results_mu1 = bind_rows(output)

sim_results_mu1
```

    ## # A tibble: 5,000 × 2
    ##    estimate p.value
    ##       <dbl>   <dbl>
    ##  1  -0.584   0.471 
    ##  2   0.396   0.686 
    ##  3  -0.416   0.667 
    ##  4  -0.0730  0.941 
    ##  5   1.03    0.158 
    ##  6   0.0726  0.946 
    ##  7  -1.11    0.204 
    ##  8   0.609   0.443 
    ##  9   0.370   0.684 
    ## 10  -2.04    0.0533
    ## # ℹ 4,990 more rows

``` r
output = vector("list", 5000)

for (i in 1:5000) {
  output[[i]] = sim_t_test(n=30,mu=2)
}

sim_results_mu2 = bind_rows(output)

sim_results_mu2
```

    ## # A tibble: 5,000 × 2
    ##    estimate p.value
    ##       <dbl>   <dbl>
    ##  1    1.03  0.300  
    ##  2    2.64  0.0130 
    ##  3    3.54  0.00193
    ##  4    1.90  0.0417 
    ##  5    2.36  0.0157 
    ##  6    3.17  0.00332
    ##  7    1.76  0.0494 
    ##  8    3.36  0.00367
    ##  9    0.663 0.446  
    ## 10    1.48  0.0857 
    ## # ℹ 4,990 more rows

Function for calculating power: the proportion of times the null was
rejected

``` r
sim_power = function ( data) {
  
  data|>
   filter(p.value < 0.05) |>
  summarize(
    power = n() / nrow(data))
  
}

sim_power(sim_results_mu2)
```

    ## # A tibble: 1 × 1
    ##   power
    ##   <dbl>
    ## 1 0.565

``` r
output = vector("list", 5000)

for (i in 1:5000) {
  output[[i]] = sim_t_test(n=30,mu=3)
}

sim_results_mu3 = bind_rows(output)

sim_results_mu3
```

    ## # A tibble: 5,000 × 2
    ##    estimate   p.value
    ##       <dbl>     <dbl>
    ##  1     2.47 0.000233 
    ##  2     3.17 0.000302 
    ##  3     2.25 0.0117   
    ##  4     3.16 0.00221  
    ##  5     2.27 0.00419  
    ##  6     2.15 0.0542   
    ##  7     2.84 0.00467  
    ##  8     2.18 0.0117   
    ##  9     1.40 0.148    
    ## 10     3.84 0.0000106
    ## # ℹ 4,990 more rows

# Problem 3
